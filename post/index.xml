<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ichx&#39;s Blog</title>
    <link>https://ichxxx.github.io/post/</link>
    <description>Recent content in Posts on ichx&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 23 Nov 2020 22:23:09 +0800</lastBuildDate><atom:link href="https://ichxxx.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go中[]byte与string的转换优化</title>
      <link>https://ichxxx.github.io/post/go%E4%B8%ADbyte%E4%B8%8Estring%E7%9A%84%E8%BD%AC%E6%8D%A2%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 23 Nov 2020 22:23:09 +0800</pubDate>
      
      <guid>https://ichxxx.github.io/post/go%E4%B8%ADbyte%E4%B8%8Estring%E7%9A%84%E8%BD%AC%E6%8D%A2%E4%BC%98%E5%8C%96/</guid>
      <description>先上优化代码： func bytesFromString(s string) []byte { tmp := (*[2]uintptr)(unsafe.Pointer(&amp;amp;s)) x := [3]uintptr{tmp[0], tmp[1], tmp[1]} return *(*[]byte)(unsafe.Pointer(&amp;amp;x)) } func stringFromBytes(b []byte) string { return *(*string)(unsafe.Pointer(&amp;amp;b)) } 一般而言，我们在Go中面对[]byte和string相互转换时，会使用内建的操作[]byte()和string()。但当我们对程序运行性能有较高要求的时候，就不得不考虑这他们的性能消耗问题。 以下源码基于Go 1.15。 内</description>
    </item>
    
    <item>
      <title>Morris Traversal方法遍历二叉树</title>
      <link>https://ichxxx.github.io/post/morris-traversal%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 24 Dec 2019 23:44:22 +0800</pubDate>
      
      <guid>https://ichxxx.github.io/post/morris-traversal%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>通常，实现二叉树遍历有两个常用的方法：一是递归，二是使用栈实现的迭代。 这两种方法都是O(n)的空间复杂度（递归本身占用stack空间或者用户自定义的stack） Morris Traversal方法只需要O(1)空间，而且同样可以在O(n)时间内完成。 要使用O(1)空间进行遍历，最大的难点在于</description>
    </item>
    
    <item>
      <title>Python中引用和对象的理解</title>
      <link>https://ichxxx.github.io/post/python%E4%B8%AD%E5%BC%95%E7%94%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Tue, 24 Dec 2019 23:41:44 +0800</pubDate>
      
      <guid>https://ichxxx.github.io/post/python%E4%B8%AD%E5%BC%95%E7%94%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      <description>Python中引用和对象是分离的。 在Python中，如果要使用一个变量，不需要提前进行声明，只需要在用的时候，给这个变量赋值即可。（这一点和C等静态类型语言不同，Python为动态类型语言） 第一个例子： a = 1 这是一个简单的赋值语句，整数 1 为一个对象，a 是一个引用，利用赋值语句，引</description>
    </item>
    
    <item>
      <title>Python代码技巧</title>
      <link>https://ichxxx.github.io/post/python%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Tue, 24 Dec 2019 23:39:01 +0800</pubDate>
      
      <guid>https://ichxxx.github.io/post/python%E4%BB%A3%E7%A0%81%E6%8A%80%E5%B7%A7/</guid>
      <description>交换值 a, b = 5, 10 a, b = b, a print(a,b) # 10 5 连接列表所有元素为一个字符串 a = [&amp;#39;Python&amp;#39;, &amp;#39;is&amp;#39;, &amp;#39;awesome&amp;#39;] print(&amp;#39; &amp;#39;.join(a)) # Python is awesome 寻找列表中频数最高的值 a = [1,2,3,1,2,3,2,2,4,5,1] f = max(set(a), key = a.count) print(f) # 2 判断两个字符串是否回文 from collections import Counter Counter(str1) == Counter(str2) 反转字符串/列表 a = &amp;#39;abcdefghijklmn&amp;#39; b = [1, 2, 3, 4, 5] print(a[::-1]) # nmlkjihgfedcba print(b[::-1]) # [5, 4, 3, 2, 1] 转置二维数组 a = [[&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;], [&amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;], [&amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;]] a_t = zip(*a) print(list(a_t)) # [(&amp;#39;a&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;e&amp;#39;), (&amp;#39;b&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;f&amp;#39;)] 链式比较</description>
    </item>
    
  </channel>
</rss>
