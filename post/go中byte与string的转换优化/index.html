<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="zh-cn">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>Go中[]byte与string的转换优化 | ichx&#39;s Blog</title>



<link rel="stylesheet" href="/css/style.css"/><link rel='stylesheet' href='https://ichxxx.github.io/css/custom.css'><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="https://ichxxx.github.io/post/go%E4%B8%ADbyte%E4%B8%8Estring%E7%9A%84%E8%BD%AC%E6%8D%A2%E4%BC%98%E5%8C%96/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://ichxxx.github.io">
          <h1 id="nav-heading" class="title is-4">ichx&#39;s Blog</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/ichxxx'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="email" href='mailto:chen@ichxxx.cn'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/go/">#Go</a>



  
  | <a class="subtitle is-6" href="/tags/performance/">#Performance</a>
  


      
    </div>
    <h2 class="subtitle is-6">November 23, 2020</h2>
    <h1 class="title">Go中[]byte与string的转换优化</h1>
    
    <div class="content">
      <p>先上优化代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bytesFromString</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">byte</span> {
    <span style="color:#a6e22e">tmp</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span>[<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>))
    <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">uintptr</span>{<span style="color:#a6e22e">tmp</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">tmp</span>[<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">tmp</span>[<span style="color:#ae81ff">1</span>]}
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>[]<span style="color:#66d9ef">byte</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">x</span>))
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">stringFromBytes</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">string</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">string</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>))
}
</code></pre></div><p>一般而言，我们在Go中面对<code>[]byte</code>和<code>string</code>相互转换时，会使用内建的操作<code>[]byte()</code>和<code>string()</code>。但当我们对程序运行性能有较高要求的时候，就不得不考虑这他们的性能消耗问题。</p>
<p>以下源码基于Go 1.15。</p>
<h2 id="内部结构分析">内部结构分析</h2>
<p>在分析<code>[]byte()</code>和<code>string()</code>的内部实现之前，先来看一下<code>string</code>和<code>slice</code>的内部结构。</p>
<h3 id="slice的内部结构">slice的内部结构</h3>
<p><code>slice</code>的内部结构可以在<code>src/runtime/slice.go</code>找到：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">slice</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">array</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
    <span style="color:#a6e22e">len</span>   <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">cap</span>   <span style="color:#66d9ef">int</span>
}
</code></pre></div><p>其中<code>array</code>指向底层数组。</p>
<h3 id="string的内部结构">string的内部结构</h3>
<p><code>string</code>的内部结构可以在<code>src/runtime/string.go</code>找到：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">stringStruct</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">str</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
    <span style="color:#a6e22e">len</span> <span style="color:#66d9ef">int</span>
}
</code></pre></div><p><code>str</code>指向的是什么呢？</p>
<p>我们可以在另外一个<code>string</code>结构中找到答案：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Variant with *byte pointer type for DWARF debugging.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">stringStructDWARF</span> <span style="color:#66d9ef">struct</span> {
	<span style="color:#a6e22e">str</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">byte</span>
	<span style="color:#a6e22e">len</span> <span style="color:#66d9ef">int</span>
}
</code></pre></div><p>这个结构是用于内部DWARF调试的，所以<code>str</code>指向了一个<code>byte</code>数组。</p>
<h3 id="小结">小结</h3>
<p>在内部结构上，<code>slice</code>比<code>string</code>只多了一个<code>cap</code>字段。</p>
<p>因为<code>string</code>的底层是一个<code>byte</code>数组，所以<code>[]byte</code>和<code>string</code>唯一的差异便是<code>cap</code>字段。</p>
<h2 id="内部实现分析">内部实现分析</h2>
<p>铺垫完上面的内容，我们来看看<code>[]byte()</code>和<code>string()</code>的内部实现是怎么样的。</p>
<h3 id="byte的内部实现">[]byte()的内部实现</h3>
<p>调用<code>[]byte()</code>操作时，实际调用的是<code>src/runtime/string.go</code>中的<code>stringtoslicebyte()</code>方法，该方法具体实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">tmpBuf</span> [<span style="color:#ae81ff">32</span>]<span style="color:#66d9ef">byte</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">stringtoslicebyte</span>(<span style="color:#a6e22e">buf</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tmpBuf</span>, <span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">byte</span> {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>
    <span style="color:#75715e">// 如果string的长度超过32，则调用rawbyteslice()，分配一块新内存
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">buf</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> len(<span style="color:#a6e22e">s</span>) <span style="color:#f92672">&lt;=</span> len(<span style="color:#a6e22e">buf</span>) {
        <span style="color:#f92672">*</span><span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">tmpBuf</span>{}
        <span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">buf</span>[:len(<span style="color:#a6e22e">s</span>)]
    } <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">b</span> = <span style="color:#a6e22e">rawbyteslice</span>(len(<span style="color:#a6e22e">s</span>))
	}
    <span style="color:#75715e">// 拷贝string中底层数组的内容到[]byte
</span><span style="color:#75715e"></span>	copy(<span style="color:#a6e22e">b</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
}

<span style="color:#75715e">// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">rawbyteslice</span>(<span style="color:#a6e22e">size</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) {
	<span style="color:#a6e22e">cap</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">roundupsize</span>(uintptr(<span style="color:#a6e22e">size</span>))
	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">cap</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cap</span> <span style="color:#f92672">!=</span> uintptr(<span style="color:#a6e22e">size</span>) {
		<span style="color:#a6e22e">memclrNoHeapPointers</span>(<span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">p</span>, uintptr(<span style="color:#a6e22e">size</span>)), <span style="color:#a6e22e">cap</span><span style="color:#f92672">-</span>uintptr(<span style="color:#a6e22e">size</span>))
	}

	<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">slice</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>)) = <span style="color:#a6e22e">slice</span>{<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">size</span>, int(<span style="color:#a6e22e">cap</span>)}
	<span style="color:#66d9ef">return</span>
}
</code></pre></div><p>可以看到，<code>[]byte()</code>操作必然会产生一次拷贝。</p>
<p>如果要转换的<code>string</code>长度大于<strong>32</strong>，还会发生一次内存分配。</p>
<h3 id="string的内部实现">string()的内部实现</h3>
<p>调用<code>string()</code>操作时，实际调用的是<code>src/runtime/string.go</code>中的<code>slicebytetostring()</code>方法，该方法具体实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// slicebytetostring converts a byte slice to a string.
</span><span style="color:#75715e">// It is inserted by the compiler into generated code.
</span><span style="color:#75715e">// ptr is a pointer to the first element of the slice;
</span><span style="color:#75715e">// n is the length of the slice.
</span><span style="color:#75715e">// Buf is a fixed-size buffer for the result,
</span><span style="color:#75715e">// it is not nil if the result does not escape.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">slicebytetostring</span>(<span style="color:#a6e22e">buf</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">tmpBuf</span>, <span style="color:#a6e22e">ptr</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">str</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#75715e">// Turns out to be a relatively common case.
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Consider that you want to parse out data between parens in &#34;foo()bar&#34;,
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// you find the indices and convert the subslice to string.
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">raceenabled</span> {
		<span style="color:#a6e22e">racereadrangepc</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">ptr</span>),
			uintptr(<span style="color:#a6e22e">n</span>),
			<span style="color:#a6e22e">getcallerpc</span>(),
			<span style="color:#a6e22e">funcPC</span>(<span style="color:#a6e22e">slicebytetostring</span>))
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">msanenabled</span> {
		<span style="color:#a6e22e">msanread</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">ptr</span>), uintptr(<span style="color:#a6e22e">n</span>))
	}
    <span style="color:#75715e">// 如果[]byte的长度为1
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
        <span style="color:#75715e">// 直接从预先分配好的staticuint64s数组中读取，避免重新分配内存
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">staticuint64s</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">ptr</span>])
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">BigEndian</span> {
			<span style="color:#a6e22e">p</span> = <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">p</span>, <span style="color:#ae81ff">7</span>)
		}
		<span style="color:#a6e22e">stringStructOf</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">str</span>).<span style="color:#a6e22e">str</span> = <span style="color:#a6e22e">p</span>
		<span style="color:#a6e22e">stringStructOf</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">str</span>).<span style="color:#a6e22e">len</span> = <span style="color:#ae81ff">1</span>
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
    <span style="color:#75715e">// 如果[]byte的长度超过32，则分配一块新内存
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">buf</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">&lt;=</span> len(<span style="color:#a6e22e">buf</span>) {
		<span style="color:#a6e22e">p</span> = <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">buf</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">p</span> = <span style="color:#a6e22e">mallocgc</span>(uintptr(<span style="color:#a6e22e">n</span>), <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>)
	}
	<span style="color:#a6e22e">stringStructOf</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">str</span>).<span style="color:#a6e22e">str</span> = <span style="color:#a6e22e">p</span>
	<span style="color:#a6e22e">stringStructOf</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">str</span>).<span style="color:#a6e22e">len</span> = <span style="color:#a6e22e">n</span>
    <span style="color:#75715e">// 拷贝[]byte中底层数组的内容到string
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">memmove</span>(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">ptr</span>), uintptr(<span style="color:#a6e22e">n</span>))
	<span style="color:#66d9ef">return</span>
}

<span style="color:#75715e">// 获取string类型结构实例
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">stringStructOf</span>(<span style="color:#a6e22e">sp</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">string</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">stringStruct</span> {
	<span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">stringStruct</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">sp</span>))
}
</code></pre></div><p><code>src/runtime/iface.go</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// staticuint64s is used to avoid allocating in convTx for small integer values.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">staticuint64s</span> = [<span style="color:#f92672">...</span>]<span style="color:#66d9ef">uint64</span>{
        <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0x01</span>, <span style="color:#ae81ff">0x02</span>, <span style="color:#ae81ff">0x03</span>, <span style="color:#ae81ff">0x04</span>, <span style="color:#ae81ff">0x05</span>, <span style="color:#ae81ff">0x06</span>, <span style="color:#ae81ff">0x07</span>,
        <span style="color:#f92672">...</span>
        <span style="color:#ae81ff">0xf8</span>, <span style="color:#ae81ff">0xf9</span>, <span style="color:#ae81ff">0xfa</span>, <span style="color:#ae81ff">0xfb</span>, <span style="color:#ae81ff">0xfc</span>, <span style="color:#ae81ff">0xfd</span>, <span style="color:#ae81ff">0xfe</span>, <span style="color:#ae81ff">0xff</span>,

}
</code></pre></div><p>要转换的<code>[]byte</code>长度， 如果为1，则没有额外的性能消耗；</p>
<p>如果大于1，则必然会发生一次拷贝；</p>
<p>如果大于<strong>32</strong>，还会发生一次内存分配。</p>
<h3 id="小结-1">小结</h3>
<p>经过一顿分析，我们可以确定，<code>[]byte()</code>和<code>string()</code>这两个内建操作，会产生一次底层数组的拷贝，如果数据量较大，还会产生一次内存分配。</p>
<h2 id="优化">优化</h2>
<p>结合<code>[]byte</code>和<code>string</code>的内部结构，显然<code>[]byte()</code>和<code>string()</code>中的拷贝和内存分配是可以被绕过的，即共享它们的底层数组，手动完成结构转换。</p>
<p>手动转换需要使用到<code>unsafe</code>包来操作类型，具体方法如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">bytesFromString</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) []<span style="color:#66d9ef">byte</span> {
    <span style="color:#75715e">// 将string类型的两个字段转化到一个临时uintptr数组
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">tmp</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span>[<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">uintptr</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>))
    <span style="color:#75715e">// 构建一个拥有完整slice类型字段的uintptr数组
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">uintptr</span>{<span style="color:#a6e22e">tmp</span>[<span style="color:#ae81ff">0</span>], <span style="color:#a6e22e">tmp</span>[<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">tmp</span>[<span style="color:#ae81ff">1</span>]}
    <span style="color:#75715e">// 将手动构建出的uintptr数组还原成slice类型
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>[]<span style="color:#66d9ef">byte</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">x</span>))
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">stringFromBytes</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">string</span> {
    <span style="color:#75715e">// 直接进行类型转换，多余的字段会被舍弃
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">string</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>))
}
</code></pre></div><h2 id="性能测试">性能测试</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_s</span> = <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Repeat</span>(<span style="color:#e6db74">&#34;foo&#34;</span>, <span style="color:#ae81ff">1024</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_b</span> = []byte(<span style="color:#a6e22e">_s</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">result</span> <span style="color:#66d9ef">interface</span>{}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkString1</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">bytes</span> <span style="color:#66d9ef">string</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">bytes</span> = string(<span style="color:#a6e22e">_b</span>)
	}
	<span style="color:#a6e22e">result</span> = <span style="color:#a6e22e">bytes</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkString2</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">bytes</span> <span style="color:#66d9ef">string</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">bytes</span> = <span style="color:#a6e22e">stringFromBytes</span>(<span style="color:#a6e22e">_b</span>)
	}
	<span style="color:#a6e22e">result</span> = <span style="color:#a6e22e">bytes</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkBytes1</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">bytes</span> []<span style="color:#66d9ef">byte</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">bytes</span> = []byte(<span style="color:#a6e22e">_s</span>)
	}
	<span style="color:#a6e22e">result</span> = <span style="color:#a6e22e">bytes</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">BenchmarkBytes2</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">B</span>) {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">bytes</span> []<span style="color:#66d9ef">byte</span>
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">N</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
		<span style="color:#a6e22e">bytes</span> = <span style="color:#a6e22e">bytesFromString</span>(<span style="color:#a6e22e">_s</span>)
	}
	<span style="color:#a6e22e">result</span> = <span style="color:#a6e22e">bytes</span>
}
</code></pre></div><p>编写如上测试，转换一个3KB的数据，得到如下结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">BenchmarkString1       <span style="color:#ae81ff">2912431</span>      <span style="color:#ae81ff">416</span> ns/op    <span style="color:#ae81ff">3072</span> B/op    <span style="color:#ae81ff">1</span> allocs/op
BenchmarkString2    <span style="color:#ae81ff">1000000000</span>    0.407 ns/op       <span style="color:#ae81ff">0</span> B/op    <span style="color:#ae81ff">0</span> allocs/op
BenchmarkBytes1        <span style="color:#ae81ff">2850360</span>      <span style="color:#ae81ff">409</span> ns/op    <span style="color:#ae81ff">3072</span> B/op    <span style="color:#ae81ff">1</span> allocs/op
BenchmarkBytes2      <span style="color:#ae81ff">502088688</span>     2.08 ns/op       <span style="color:#ae81ff">0</span> B/op    <span style="color:#ae81ff">0</span> allocs/op
</code></pre></div><p>采用直接转换，在无需分配额外内存的同时，其转换耗时也几乎可以忽略。</p>
<p>当然，采用内建操作的这400ns差异在大部分场景下也是几乎可以忽略的。</p>
<p>那如果需要转换的数据不是3KB，而是3MB呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">BenchmarkString1          <span style="color:#ae81ff">5917</span>    <span style="color:#ae81ff">199307</span> ns/op    <span style="color:#ae81ff">3145730</span> B/op    <span style="color:#ae81ff">1</span> allocs/op
BenchmarkString2    <span style="color:#ae81ff">1000000000</span>     0.399 ns/op          <span style="color:#ae81ff">0</span> B/op    <span style="color:#ae81ff">0</span> allocs/op
BenchmarkBytes1        <span style="color:#ae81ff">2850360</span>    <span style="color:#ae81ff">190067</span> ns/op    <span style="color:#ae81ff">3145734</span> B/op    <span style="color:#ae81ff">1</span> allocs/op
BenchmarkBytes2      <span style="color:#ae81ff">558141092</span>      2.10 ns/op          <span style="color:#ae81ff">0</span> B/op    <span style="color:#ae81ff">0</span> allocs/op
</code></pre></div><p>可以看到，直接转换不受数据量增大的影响，而内建操作的耗时则随着数据量的增大而增加。</p>
<p>在3MB的数据量下，其一次操作的耗时已经接近0.2ms。</p>
<p>假设我们需要在1秒内进行1000次运算，即1ms运算一次，而一次内建操作的转换就已经占用了五分之一的耗时，同时需要分配跟转换对象同等大小的内存，如此的性能消耗使得我们不得不考虑进去。</p>
<h2 id="局限">局限</h2>
<p>直接转换的性能提升是以牺牲安全性为代价的，因为我们在两个不同类型结构中，共享了同一个底层数组。</p>
<p>在Go中，<code>string</code>类型是不可变的，而<code>[]byte</code>类型则是可以被修改的。</p>
<p>假设我们需要修改通过直接转换而来的<code>[]byte</code>，那么同时也会对<code>string</code>的底层数组做出修改，这样会造成严重的错误！</p>
<p><strong>如果你的程序不能保证通过直接转换而来的<code>[]byte</code>不被修改，则不推荐使用该方法。</strong></p>
<h2 id="总结">总结</h2>
<p>在对程序运行性能有较高要求且对数据只有读操作的场景，通过使用<code>unsafe</code>包，我们可以在高性能且无需分配额外内存的情况下，完成<code>[]byte</code>和<code>string</code>的相互转换。</p>

      
      <div class="related">
</div>
      
    </div>
    
  </div>
</section>



<section class="section">
  <div class="container has-text-centered">
    <p></p>
    
  </div>
</section>



</body>
</html>

