---
title: "Python中引用和对象的理解"
date: 2019-12-24T23:41:44+08:00
draft: false
tags: ["Python"]
---

> Python中引用和对象是分离的。

在Python中，如果要使用一个变量，不需要提前进行声明，只需要在用的时候，给这个变量赋值即可。（这一点和C等静态类型语言不同，Python为动态类型语言）



### 第一个例子

```python
a = 1
```

这是一个简单的赋值语句，整数 1 为一个对象，a 是一个引用，利用赋值语句，引用 a 指向了对象 1 。



### 第二个例子

```python
a = 1
b = 1

print(id(a))
# 496624400
print(id(b))
# 496624400
```

a 和 b 两个引用指向了同一个对象（内存地址），这是为什么呢？ 这个跟Python的内存机制有关系，因为对于语言来说，频繁地进行对象的销毁和建立，特别浪费性能。所以在Python中，整数和短小的字符，Python都会缓存这些对象，以便重复使用。



### 第三个例子

```python
a = 1
b = a

print(id(a))
# 496624400
print(id(b))
# 496624400
```

可以看到 a 和 b 都指向了整数对象 1 。

```python
a = a + 1

print(id(a))
# 496624416
print(id(b))
# 496624400
```

可以看到 a 的引用改变了，但是 b 的引用未发生改变。a，b指向不同的对象。
因为我们对 a 进行了重新赋值，让它指向了新的对象 2 。即使是多个引用指向同一个对象，如果一个引用值发生变化，那么实际上是让这个引用指向一个新的引用，并不影响其他的引用的指向。从效果上看，就是各个引用各自独立，互不影响。



### 第四个例子

```python
a = [1, 2, 3]
b = a

print(id(a))
# 62228800
print(id(b))
# 62228800

a[0] = 10

print(id(a))
# 62228800
print(id(b))
# 62228800

print(b)
# [10, 2, 3]
```

我们修改了对象 a 的值，但是结果并不如前一个例子那样。在这个例子中，a 和 b 的引用没有发生任何变化，但是列表对象 [1, 2, 3] 的值变成了 [10, 2, 3]。
在该情况下，我们不再对 a 这一引用赋值，而是对 a 所指向的列表的元素赋值，结果是 b 也同时发生变化。



### 为什么
因为 a，b 的指向没有发生变化，依然指向那个列表。



列表实际上是包含了多个引用的对象（每个引用是一个元素，比如a[0]，a[1] ..., 每个引用指向一个对象，比如 1, 2 ...）, 而 a[0] = 10 这一赋值操作，并不是改变 a 的指向，而是对 a[0]，也就是列表对象的一部份（一个元素）进行操作，所以所有指向该对象的引用都受到影响。
（与之形成对比的是，我们之前的赋值操作都没有对对象自身发生作用，只是改变引用指向。）

列表可以通过引用其元素，改变对象自身（in-place change）。这种对象类型，称为**可变数据对象**（mutable object），字典也是这样的数据类型。
而像之前的数字和字符串，不能改变对象本身，只能改变引用的指向，称为**不可变数据对象**（immutable object）。
同理，元组（tuple）尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是不可变数据对象。

如果我们想知道引用是否指向同一个对象，我们可以使用Python的 **is关键词**，is 用于判断两个引用所指的对象是否相同。

```python
a = 1          # id(a) == 496624400
b = 1          # id(b) == 496624400
print(a is b)
# True

a = a + 1      # id(a) == 496624416
print(a is b)
# False
```